#include <bits/stdc++.h>
using namespace std;

int n;
int S[303], D[303];

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	cin >> n;
	int sum = 0;
	for (int i = 1; i <= n; ++i) {
		cin >> S[i];
		sum += S[i];
	}

	if (n <= 2) {
		cout << sum;
		return 0;
	}

	D[1] = S[1];
	D[2] = S[2];
	D[3] = S[3];

	for (int i = 4; i <= n; ++i)
		D[i] = min(D[i - 2], D[i - 3]) + S[i];

	cout << sum - min(D[n - 1], D[n - 2]);
}

/*

관점을 살짝 바꿔서 보면 2차원 배열 대신 1차원 배열로 문제를 해결할 수 있다.
1. 테이블 정의하기
	이번에는 밟지 않을 계단을 선택한다. N번째 계단까지 점수의 최댓값을 구하는 상황은 곧 밟지 않을 계단의 합을 최소로 만드는 상황과 같다. 
	D[i] = i번째 계단까지 올라섰을 때 밟지 않을 계단의 합의 최솟값, 단 i번째 계단은 반드시 밟지 않을 계단으로 선택해야 한다.
	계단을 오르는 규칙을 살짝 비틀어서 생각해 보면 k번째 계단을 밟지 않았으면 k-1번째 계단은 무조건 밟아야 한다. 왜냐면 계단은 한 번에 한 계단씩 또는 두 계단씩으로만 오를 수 있기 때문이다. 그리고 k-2번째 계단이나 k-3번째 계단 중 하나는 무조건 밟아야 한다. 즉 k번째 계단을 밟지 않을거면 k-2번째나 k-3번째 계단 중 하나를 안밟아야 한다. 
	따라서 D[k] = min(D[k-2], D[k-3]) + S[k]

2. 점화식 찾기
	D[k] = min(D[k-2], D[k-3]) + S[k]

3. 초기값 정하기
	D[k]를 구할 때 D[k-3]이 쓰이니까 D[1], D[2], D[3]까지를 초기값으로 둔다.
	D[1] = S[1]
	D[2] = S[2]
	D[3] = S[3]

4. 출력
	N개의 계단이 있을 때 문제의 조건에서 마지막 도착 계단은 반드시 밟아야 한다. 그러므로 가장 마지막으로 선택될 밟지 않을 계단은 N-1번째 또는 N-2번째 계단이다. 그래서 (계단에 적힌 점수의 총합) - min(D[N-1], D[N-2])가 출력이다.
*/