#include <bits/stdc++.h>
using namespace std;

int n;
int D[1'000'003], pre[1'000'003];

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	cin >> n;
	D[1] = 0;
	pre[1] = 0;

	for (int i = 2; i <= n; ++i) {
		D[i] = D[i - 1] + 1;
		pre[i] = i - 1;
		if (i % 2 == 0) {
			D[i] = min(D[i], D[i / 2] + 1);
			if (D[i] == D[i / 2] + 1)
				pre[i] = i / 2;
		}
		if (i % 3 == 0) {
			D[i] = min(D[i], D[i / 3] + 1);
			if (D[i] == D[i / 3] + 1)
				pre[i] = i / 3;
		}
	}

	cout << D[n] << '\n';

	int cur = n;
	while (true) {
		cout << cur << ' ';
		if (cur == 1) break;
		cur = pre[cur];
	}
}

/*

DP에서 경로를 추적하는 방법을 알아보자. 이런 문제를 해결하려면 테이블을 채울 때 추가적인 정보를 어딘가에 기입해야 한다. 원래 테이블을 값 테이블(D), 추가적인 정보를 기입할 테이블을 경로 복원용 테이블(pre)라고 부르자.

D[1]은 당연히 0이다. pre[1]은 어차피 참조되지 않는 값이므로 큰 의미를 두지 않아도 된다.
D[2]를 정할 때를 보자, 2는 -1을 하거나 /2를 통해 1로 바뀔 수 있으니 D[2] = D[1] + 1 = 1이다. 이 때 pre[2]에 1을 적어준다. 이 1의 의미는 2에서 1로 가는게 최적이라는 의미이다.
D[3]을 정할 때를 보자, 3은 -1을 해서 2가 되거나 /3을 해서 1이 될 수 있다. 이 때 D[1]이 D[2]보다 작으니 D[3] = D[1] + 1 = 1 이다. 그래서 D[3] = 2, pre[3] = 1이 된다. 

경로 복원용 테이블을 다 구하면 이 값을 가지고 1까지 도달하면 된다. 예를 들어 7이라면 7은 6으로부터 왔으니 6으로 가고, 6은 3으로부터 왔으니 3으로, 3은 1에서부터 왔으니 1로 간다. 이렇게 7 6 3 1 이라는 경로를 찾을 수 있다.

이렇게 내 값이 어디서부터 온 것인가를 따로 저장한 후 나중에 경로를 복원하면 된다. 똑같은 원리로 BFS에서도 경로 복원이 가능하다. 

*/