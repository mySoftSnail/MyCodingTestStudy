#include <bits/stdc++.h>
using namespace std;

int n;
int D[1003];

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	cin >> n;

	D[1] = 1;
	D[2] = 2;
	for (int i = 3; i <= n; ++i) 
		D[i] = (D[i - 1] + D[i - 2]) % 10007; // int overflow가 되지 않도록 계산 중간 중간에 계속 10007로 나눈 나머지를 얻도록 한다
	
	cout << D[n];
}

/*

1. 테이블 정의하기
	D[i] = 2 X i 크기의 직사각형을 채우는 방법의 수

2. 점화식 찾기
	가장 왼쪽 위의 칸을 보자. 그 칸은 결국 1x2 타일 또는 2x1타일로 덮여야 한다.
	먼저 2x1 타일(세로 타일)로 덮어보자. 남은 칸은 2 x n-1칸이다. 이 남은 2 x n-1 칸을 채우는 방법의 수는 테이블의 정의에 따라 D[n-1]이다. 따라서, 가장 왼쪽 칸을 세로 타일로 덮는 경우의 수는 D[n-1]이다.
	그 다음은 1x2 타일(가로 타일)로 덮어보자. 이 타일의 아래 칸을 덮는 타일도 무조건 1x2로 정해져 있다. 그러면 남은 칸은 2 x n-2 칸이며, 채우는 방법의 수는 D[n-2]이다.
	따라서 2xn칸을 채울 때 왼쪽 위의 칸을 2x1타일로 덮는다면 D[n-1]가지가 있고, 왼쪽 위의 칸을 1x2타일로 덮는다면 D[n-2]가지가 있다. 따라서 D[n] = D[n-1] + D[n-2] 이다.

3. 초기값 정하기
	D[n]을 구할 때 D[n-1]과 D[n-2]가 필요하니 D[1]과 D[2]에 초기값을 준다.
	D[1] = 1
	D[2] = 2

*/