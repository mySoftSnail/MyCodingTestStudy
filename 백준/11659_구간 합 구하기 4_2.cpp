#include <bits/stdc++.h>
using namespace std;

int A[100'003], D[100'003];
int n, m;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	cin >> n >> m;
	for (int i = 1; i <= n; ++i)
		cin >> A[i];

	D[1] = A[1];
	for (int i = 2; i <= n; ++i)
		D[i] = D[i - 1] + A[i];

	while (m--) {
		int i, j;
		cin >> i >> j;
		cout << D[j] - D[i - 1] << '\n';
	}
}

/*

시간복잡도를 생각하지 않는다면 간단하게 풀 수 있겠지만, 각 질의에서 최대 N번의 숫자를 더해야 하고 그런 질의가 최대 M개 이므로 시간복잡도는 O(NM)이 된다. N,M의 크기를 생각해 봤을 때 NxM은 100억이니 이런 방법으로는 시간 제한을 절대 통과할 수 없다.

1. 테이블 정의하기
	D[i] = A[1] + A[2] + ... + A[i]로 정의하자.
	
2. 점화식 찾기
	D[i]를 구할 때 매번 i개의 수를 더할 필요가 없다. D[i] = D[i-1] + A[i]임을 이용하면 전체를 O(N)에 채울 수 있다.
	
3. 초기값 정하기
	D[1] = A[1]

이제 이 D 테이블로 문제의 정답만 구하면 된다.
A[i] + A[i+1] + ... + A[j]
	= (A[1] + A[2] + ... + A[j]) - (A[1] + A[2] + ... + A[i-1])
	= D[j] - D[i-1] 이다.

이 문제에서 사용한 기법을 Prefix sum이라고 한다. 문제를 푸는 과정에서 시간복잡도를 줄이는 기법으로 쓰기도 한다.

*/