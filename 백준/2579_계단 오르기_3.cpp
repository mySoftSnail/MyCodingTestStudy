#include <bits/stdc++.h>
using namespace std;

int S[303];
int D[303][3];
int n;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	cin >> n;
	for (int i = 1; i <= n; ++i)
		cin >> S[i];

	if (n == 1) { cout << S[1]; return 0; } // 예외 처리

	D[1][1] = S[1];
	D[1][2] = 0;
	D[2][1] = S[2];
	D[2][2] = S[1] + S[2];

	for (int i = 3; i <= n; ++i) {
		D[i][1] = max(D[i - 2][1], D[i - 2][2]) + S[i];
		D[i][2] = D[i - 1][1] + S[i];
	}

	cout << max(D[n][1], D[n][2]);
}

/*

1. 테이블 정의하기
	D[i][j] = 현재까지 j개의 계단을 연속해서 밟고 i번째 계단까지 올라섰을 때 점수 합의 최댓값, 
	단 i번째 계단은 반드시 밟아야 함
	2차원 배열을 사용하는 이유는 지금까지 몇 개의 계단을 밟았는지에 대한 정보가 추가로 있어야 점화식을 세울 때 계단을 오르는 규칙을 고려할 수 있기 때문이다. 그리고 반드시 '단 i번째 계단은 반드시 밟아야 함' 이라는 조건이 있어야 점화식을 이끌어낼 수 있다.
	i번째 계단을 무조건 밟으므로 j는 1또는 2다. 연속된 세 계단을 밟을 수 없으므로 j가 3 이상일 수는 없다.

2. 점화식 찾기
	 D[k][1] = ?
	 테이블의 정의에 의하면 D[k][1]은 현재까지 1개의 계단을 연속해서 밟고 k번째 계단까지 올라섰을 때 점수 합의 최댓값이다. 현재까지 1개의 계단을 연속해서 밟았다는 의미는 곧 k-1번째 계단은 밟지 않았다는 것이 된다. 대신 k-2번째 계단을 밟았다는 것이 자명하다.
	 위의 내용을 통해 점화식을 이끌어 낼 수 있다. 점화식만 이끌어내는게 목표이니 k-2번째 밑으로 내려갈 필요는 없다. k-2번째 계단을 밟았을 때 얻은 점수의 최댓값은 D[k-2][1] 또는 D[k-2][2]에 저장되어 있을 것이다. 
	 따라서 최종적으로 D[k][1] = max(D[k-2][1], D[k-2][2]) + S[k] 이다. S[k]는 k번째 계단에 쓰여 있는 점수이다.
	 D[k][2] = ?
	 D[k][2]는 현재까지 2개의 계단을 연속해서 밟고 k번째 계단까지 올라섰을 때 점수 합의 최댓값이다. 현재까지 2개의 계단을 밟았으니 k-1번째 계단을 밟았다는 건 알 수 있는데, 추가적인 조건이 하나 더 있다.
	 k-1번째 계단을 밟을 당시에는 1개의 계단을 연속해서 밟은 상태여야만 한다. 만약 k-1번째 계단을 밟을 당시 2개의 계단을 밟은 상태라면 k번째 계단을 밟을 때에는 세 번째 계단을 밟은 것이 되기 때문이다.
	 따라서 D[k][2] = D[k-1][1] + S[k] 이다.
	 이제 점화식을 가지고 테이블을 채운 뒤 마지막 도착 계단은 반드시 밟아야 한다는 조건에 따라 max(D[N][1], D[N][2])를 출력하면 된다.

3. 초기값 정하기
	점화식을 구할 때 보았듯이, D[k][1]을 구할 때에는 D[k-1][1], D[k-2][2] 값이 필요하다. 
	그러므로 D[1][1], D[1][2], D[2][1], D[2][2]에 초기값을 주어야 한다.  
	D[1][1] = S[1]
	D[1][2] = 0
	D[2][1] = S[2]
	D[2][2] = S[1] + S[2] 이다.

*/